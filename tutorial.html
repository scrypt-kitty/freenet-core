<!DOCTYPE HTML>
<html lang="en" class="light" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Tutorial: Create an App - Freenet Manual</title>


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body class="sidebar-visible no-js">
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('light')
            html.classList.add(theme);
            var body = document.querySelector('body');
            body.classList.remove('no-js')
            body.classList.add('js');
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var body = document.querySelector('body');
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            body.classList.remove('sidebar-visible');
            body.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="introduction.html"><strong aria-hidden="true">1.</strong> Introduction</a></li><li class="chapter-item expanded affix "><li class="part-title">Components</li><li class="chapter-item expanded "><a href="components/overview.html"><strong aria-hidden="true">2.</strong> Overview</a></li><li class="chapter-item expanded "><a href="components/contracts.html"><strong aria-hidden="true">3.</strong> Contracts</a></li><li class="chapter-item expanded "><a href="components/delegates.html"><strong aria-hidden="true">4.</strong> Delegates</a></li><li class="chapter-item expanded "><a href="components/ui.html"><strong aria-hidden="true">5.</strong> User Interfaces</a></li><li class="chapter-item expanded affix "><li class="part-title">Architecture</li><li class="chapter-item expanded "><a href="architecture/p2p-network.html"><strong aria-hidden="true">6.</strong> P2P Network</a></li><li class="chapter-item expanded "><a href="architecture/irouting.html"><strong aria-hidden="true">7.</strong> Intelligent Routing</a></li><li class="chapter-item expanded "><a href="architecture/transport.html"><strong aria-hidden="true">8.</strong> Transport</a></li><li class="chapter-item expanded affix "><li class="part-title">Developer Guide</li><li class="chapter-item expanded "><a href="tutorial.html" class="active"><strong aria-hidden="true">9.</strong> Tutorial: Create an App</a></li><li class="chapter-item expanded "><a href="contract-interface.html"><strong aria-hidden="true">10.</strong> Contract interfaces</a></li><li class="chapter-item expanded "><a href="manifest.html"><strong aria-hidden="true">11.</strong> freenet.toml format</a></li><li class="chapter-item expanded affix "><li class="part-title">Examples</li><li class="chapter-item expanded "><a href="examples/antiflood-tokens.html"><strong aria-hidden="true">12.</strong> Antiflood Tokens</a></li><li class="chapter-item expanded "><a href="examples/blind-trust-tokens.html"><strong aria-hidden="true">13.</strong> Blind Trust Tokens</a></li><li class="chapter-item expanded affix "><li class="part-title">Community and Support</li><li class="chapter-item expanded "><a href="community.html"><strong aria-hidden="true">14.</strong> Community</a></li><li class="chapter-item expanded affix "><li class="part-title">Reference</li><li class="chapter-item expanded "><a href="glossary.html"><strong aria-hidden="true">15.</strong> Glossary</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Freenet Manual</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="introduction"><a class="header" href="#introduction">Introduction</a></h1>
<p>This tutorial will show you how to build decentralized software on Freenet. For a practical
reference, please see the example application at <a href="https://github.com/freenet/freenet-core/tree/main/apps/freenet-email-app">apps/freenet-email-app</a>.</p>
<ul>
<li><a href="#prerequisites">Prerequisites</a>
<ul>
<li><a href="#rust-and-cargo">Rust and Cargo</a>
<ul>
<li><a href="#note-for-macos-install">Note for MacOS install</a></li>
</ul>
</li>
<li><a href="#installing-freenet-core-and-fdev-from-git">Installing Freenet Core and FDev from Git</a></li>
<li><a href="#freenet-development-tool-and-kernel">Freenet Development Tool and Kernel</a></li>
<li><a href="#add-webassembly-target">Add WebAssembly target</a></li>
<li><a href="#nodejs-and-typescript">Node.js and TypeScript</a></li>
</ul>
</li>
<li><a href="#creating-a-new-contract">Creating a new contract</a></li>
<li><a href="#making-a-container-contract">Making a container contract</a>
<ul>
<li><a href="#creating-a-web-application">Creating a web application</a></li>
</ul>
</li>
<li><a href="#writing-the-backend-for-our-web-application">Writing the backend for our web application</a>
<ul>
<li><a href="#building-and-packaging-a-contract">Building and packaging a contract</a></li>
</ul>
</li>
<li><a href="#testing-out-contracts-in-the-local-node">Testing out contracts in the local node</a></li>
<li><a href="#limitations">Limitations</a></li>
</ul>
<h2 id="prerequisites"><a class="header" href="#prerequisites">Prerequisites</a></h2>
<h3 id="rust-and-cargo"><a class="header" href="#rust-and-cargo">Rust and Cargo</a></h3>
<p>To install a Rust development environment, including Cargo, on Linux or macOS
(for Windows installation, refer to <a href="https://rustup.rs">this guide</a>), use the
following command:</p>
<pre><code class="language-bash">curl https://sh.rustup.rs -sSf | sh
</code></pre>
<h4 id="note-for-macos-install"><a class="header" href="#note-for-macos-install">Note for MacOS install</a></h4>
<p>Note: The Homebrew installation of Rust may interfere with <code>fdev</code>. It is
recommended to use <code>rustup</code>, as shown above, to avoid these issues.</p>
<h3 id="installing-freenet-core-and-fdev-from-git"><a class="header" href="#installing-freenet-core-and-fdev-from-git">Installing Freenet Core and FDev from Git</a></h3>
<ul>
<li>Clone the Freenet Core repository and the stdlib submodule, and navigate to the application directory:</li>
</ul>
<p><em>Note:</em> Currently these should be installed from the git repo as the code is changing rapidly, once things
are more stable they can be installed from crates.io which will simplify this step.</p>
<pre><code class="language-bash">git clone --recurse-submodules https://github.com/freenet/freenet-core.git
cd freenet-core/apps/freenet-ping
</code></pre>
<h3 id="freenet-development-tool-and-kernel"><a class="header" href="#freenet-development-tool-and-kernel">Freenet Development Tool and Kernel</a></h3>
<ul>
<li>
<p>Install the Freenet development tool (<code>fdev</code>) and the Freenet kernel for local development:</p>
<pre><code class="language-bash"># You should be in freenet-core/apps/freenet-ping
cargo install --path ../../crates/core
cargo install --path ../../crates/fdev
</code></pre>
</li>
</ul>
<h3 id="add-webassembly-target"><a class="header" href="#add-webassembly-target">Add WebAssembly target</a></h3>
<p>To allow Rust to compile to WebAssembly, you need to add the WebAssembly target using <code>rustup</code>:</p>
<pre><code class="language-bash">rustup target add wasm32-unknown-unknown
</code></pre>
<h3 id="nodejs-and-typescript"><a class="header" href="#nodejs-and-typescript">Node.js and TypeScript</a></h3>
<p>To build user interfaces in JavaScript or TypeScript, you need to have Node.js
and npm installed. For example on Ubuntu Linux:</p>
<pre><code class="language-bash">sudo apt update
sudo apt install nodejs npm
</code></pre>
<p>For Mac or Windows, you can download Node.js and npm from <a href="https://nodejs.org/en/download/">here</a>.</p>
<p>Once Node.js and npm are installed, you can install TypeScript globally on your
system, which includes the <code>tsc</code> command:</p>
<pre><code class="language-bash">sudo npm install -g typescript
</code></pre>
<p>You can verify the installation by checking the version of <code>tsc</code>:</p>
<pre><code class="language-bash">tsc --version
</code></pre>
<p>This command should output the version of TypeScript that you installed.</p>
<h2 id="creating-a-new-contract"><a class="header" href="#creating-a-new-contract">Creating a new contract</a></h2>
<p>You can create a new <a href="glossary.html#contract">contract</a> skeleton by executing the
<code>new</code> command with <code>fdev</code>. Fdev supports two types of contracts:
regular <a href="glossary.html#contract">contracts</a>, and <a href="glossary.html#web-application">web application</a> <a href="glossary.html#container-contract">container
contracts</a>. Fdev supports several languages:</p>
<ul>
<li>Regular contracts:
<ul>
<li>Rust (<em>default</em>)</li>
</ul>
</li>
<li>Web applications:
<ul>
<li>Container development:
<ul>
<li>Rust (<em>default</em>)</li>
</ul>
</li>
<li>Web/state development:
<ul>
<li>TypeScript. (<em>default: using npm and webpack</em>)</li>
<li>JavaScript.</li>
<li>Rust (<strong>WIP</strong>).</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>We create a directory to hold our web app, and initialize it using <code>fdev</code>:</p>
<pre><code class="language-bash">mkdir -p my-app/web
mkdir -p my-app/backend
cd my-app/web
fdev new web-app
</code></pre>
<p>This will create the skeleton for a web application and its container contract for
Freenet ready for development at the <code>my-app/web</code> directory.</p>
<h2 id="making-a-container-contract"><a class="header" href="#making-a-container-contract">Making a container contract</a></h2>
<p>The first thing that we need is to write the code for our container contract.
This contract's role is to contain the web application code itself, allowing it
to be distributed over Freenet.</p>
<p>The <code>new</code> command has created the source ready to be modified for us, in your
favorite editor open the following file:</p>
<pre><code class="language-bash">./container/src/lib.rs
</code></pre>
<p>In this case, and for simplicity's sake, the contract won't be performing any
functions, but in a realistic scenario, this contract would include some basic
security functionality like verifying that whoever is trying to update the
contract has the required credentials.</p>
<p>To make our contract unique so it doesn't collide with an existing contract, we
can generate a random signature that will be embedded with the contract.</p>
<!--
What would happen in case of a collision with an existing contract? (That would be if we try to publish a contract that has the same combination of code and parameters.) Then it would fail to publish our contract in the network and would get a rejection because we would be trying to update an existing contract. And we would have to make a slight change in the code/parameters so this collision is avoided. To make this work, there needs to exist a type, which requires (this can be only done once, at the top level of the library crate) implementing the `ContractInterface` trait from `freenet-stdlib`.
-->
<p>For example in the <code>lib.rs</code> file we will write the following:</p>
<pre><code class="language-rust no_run noplayground">use freenet_stdlib::prelude::*;

pub const RANDOM_SIGNATURE: &amp;[u8] = &amp;[6, 8, 2, 5, 6, 9, 9, 10];

struct Contract;

#[contract]
impl ContractInterface for Contract {
    fn validate_state(
        _parameters: Parameters&lt;'static&gt;,
        _state: State&lt;'static&gt;,
        _related: RelatedContracts&lt;'static&gt;,
    ) -&gt; Result&lt;ValidateResult, ContractError&gt; {
        unimplemented!()
    }

    fn update_state(
        _parameters: Parameters&lt;'static&gt;,
        _state: State&lt;'static&gt;,
        _data: Vec&lt;UpdateData&lt;'static&gt;&gt;,
    ) -&gt; Result&lt;UpdateModification&lt;'static&gt;, ContractError&gt; {
        unimplemented!()
    }

    fn summarize_state(
        _parameters: Parameters&lt;'static&gt;,
        _state: State&lt;'static&gt;,
    ) -&gt; Result&lt;StateSummary&lt;'static&gt;, ContractError&gt; {
        unimplemented!()
    }

    fn get_state_delta(
        _parameters: Parameters&lt;'static&gt;,
        _state: State&lt;'static&gt;,
        _summary: StateSummary&lt;'static&gt;,
    ) -&gt; Result&lt;StateDelta&lt;'static&gt;, ContractError&gt; {
        unimplemented!()
    }
}</code></pre>
<p>That's a lot of information, let's unpack it:</p>
<pre><code class="language-rust noplayground">use freenet_stdlib::prelude::*;</code></pre>
<p>Here we are importing the necessary types and traits to write a Freenet contract
successfully using Rust.</p>
<pre><code class="language-rust noplayground">pub const RANDOM_SIGNATURE: &amp;[u8] = &amp;[6, 8, 2, 5, 6, 9, 9, 10];</code></pre>
<p>This will make our contract unique, notice the <code>pub</code> qualifier so the compiler
doesn't remove this constant because is unused and is included in the output of
the compiler.</p>
<pre><code class="language-rust noplayground">struct Contract;

#[contract]
impl ContractInterface for Contract {
  ...
}</code></pre>
<!--
TODO: Elsewhere in the documentation, explain the intricate details of how interfacing through WASM works. In theory users could implement their own wrapping code as long as the follow the low level WASM code specification.
-->
<p>Here we create a new type, <code>Contract</code> for which we will be implementing the
<code>ContractInterface</code> trait. To know more details about the functionality of a
contract, delve into the details of the <a href="contract-interface.html">contract
interface</a>.</p>
<p>Notice the <code>#[contract]</code> macro call, this will generate the necessary code for
the WASM runtime to interact with your contract ergonomically and safely. Trying
to use this macro more than once in the same module will result in a compiler
error, and only the code generated at the top-level module will be used by the
runtime.</p>
<p>As a rule of thumb, one contract will require implementing the
`ContractInterface`` exactly once.</p>
<h3 id="creating-a-web-application"><a class="header" href="#creating-a-web-application">Creating a web application</a></h3>
<p>Now we have a working example of a contract, but our contract is an empty shell,
which does not do anything yet. To change this, we will start developing our web
application.</p>
<p>To do that, we can go and modify the code of the contract state, which in this
case is the web application. Freenet offers a standard library (stdlib) that can
be used with Typescript/JavaScript to facilitate the development of web
applications and interfacing with your local node, so we will make our
<code>package.json</code> contains the dependency:</p>
<pre><code class="language-json">{
  "dependencies": {
    "@freenetorg/freenet-stdlib": "0.0.6"
  }
}
</code></pre>
<p>Open the file <code>src/index.ts</code> in a code editor and you can start developing the
web application.</p>
<p>An important thing to notice is that our application will need to interface with
our local node, the entry point for our machine to communicate with other nodes
in the network. The stdlib offers a series of facilities in which you will be
able to communicate with the network ergonomically.</p>
<p>Here is an example of how you could write your application to interact with the
node:</p>
<pre><code class="language-typescript">import {
  GetResponse,
  HostError,
  Key,
  FreenetWsApi,
  PutResponse,
  UpdateNotification,
  UpdateResponse,
  DelegateResponse,
} from "@freenetorg/freenet-stdlib/websocket-interface";

const handler = {
  onContractPut: (_response: PutResponse) =&gt; {},
  onContractGet: (_response: GetResponse) =&gt; {},
  onContractUpdate: (_up: UpdateResponse) =&gt; {},
  onContractUpdateNotification: (_notif: UpdateNotification) =&gt; {},
  onDelegateResponse: (_response: DelegateResponse) =&gt; {},
  onErr: (err: HostError) =&gt; {},
  onOpen: () =&gt; {},
};

const API_URL = new URL(`ws://${location.host}/contract/command/`);
const freenetApi = new FreenetWsApi(API_URL, handler);

const CONTRACT = "DCBi7HNZC3QUZRiZLFZDiEduv5KHgZfgBk8WwTiheGq1";

async function loadState() {
  let getRequest = {
    key: Key.fromSpec(CONTRACT),
    fetch_contract: false,
  };
  await freenetApi.get(getRequest);
}
</code></pre>
<p>Let's unpack this code:</p>
<pre><code class="language-typescript">const handler = {
  onPut: (_response: PutResponse) =&gt; {},
  onGet: (_response: GetResponse) =&gt; {},
  onUpdate: (_up: UpdateResponse) =&gt; {},
  onUpdateNotification: (_notif: UpdateNotification) =&gt; {},
  onErr: (err: HostError) =&gt; {},
  onOpen: () =&gt; {},
};

const API_URL = new URL(`ws://${location.host}/contract/command/`);
const freenetApi = new FreenetWsApi(API_URL, handler);
</code></pre>
<p>This type provides a convenient interface to the WebSocket API. It receives an
object which handles the different responses from the node via callbacks. Here
you would be able to interact with DOM objects or other parts of your code.</p>
<pre><code class="language-typescript">const CONTRACT = "DCBi7HNZC3QUZRiZLFZDiEduv5KHgZfgBk8WwTiheGq1";

async function loadState() {
  let getRequest = {
    key: Key.fromSpec(CONTRACT),
    fetch_contract: false,
  };
  await freenetApi.get(getRequest);
}
</code></pre>
<p>Here we use the API wrapper to make a get request (which requires a key and
specifies if we require fetching the contract code or not) to get the state for
a contract with the given address. The response from the node will be directed
to the <code>onGet</code> callback. You can use any other methods available in the API to
interact with the node.</p>
<!--
TODO: Add a link to documentation for the WebSocket API in typescript
-->
<h2 id="writing-the-backend-for-our-web-application"><a class="header" href="#writing-the-backend-for-our-web-application">Writing the backend for our web application</a></h2>
<p>In the <a href="dev-guide.html#creating-a-new-contract">creating a new contract</a> section
we described the contract interface, but we were using it to write a simple
container contract that won't be doing anything in practice, just carrying
around the front end of your application. The core logic of the application, and
a back end where we will be storing all the information, requires another
contract. So we will create a new contract in a different directory for it:</p>
<pre><code class="language-bash">cd ../backend
fdev new contract
</code></pre>
<p>This will create a regular contract, and we will need to implement the interface
on a type that will handle our contract code. For example:</p>
<pre><code class="language-rust noplayground">use freenet_stdlib::prelude::*;

pub const RANDOM_SIGNATURE: &amp;[u8] = &amp;[6, 8, 2, 5, 6, 9, 9, 10];

struct Contract;

struct Posts(...)

impl Posts {
  fn add_post(&amp;mut self, post: Post) { ... }
}

struct Post(...)

#[contract]
impl ContractInterface for Contract {
    fn update_state(
        _parameters: Parameters&lt;'static&gt;,
        state: State&lt;'static&gt;,
        data: Vec&lt;UpdateData&lt;'static&gt;&gt;,
    ) -&gt; Result&lt;UpdateModification&lt;'static&gt;, ContractError&gt; {
        let mut posts: Posts = serde_json::from_slice(&amp;state).map_err(|_| ContractError::InvalidState)?;
        if let Some(UpdateData::Delta(delta)) = data.pop() {
          let new_post: Posts = serde_json::from_slice(&amp;delta).map_err(|_| ContractError::InvalidState);
          posts.add_post(new_post)?;
        } else {
            Err(ContractError::InvalidUpdate)
        }
        Ok(UpdateModification::valid(posts.into()))
    }

    ...
}</code></pre>
<p>In this simple example, we convert a new incoming delta to a post and the state
to a list of posts we maintain, and we append the post to the list of posts.
After that, we convert back the posts list to an state and return that.</p>
<p>If we subscribe to the contract changes or our web app, we will receive a
notification with the updates after they are successful, and we will be able to
render them in our browser. We can do that, for example, using the API:</p>
<pre><code class="language-typescript">function getUpdateNotification(notification: UpdateNotification) {
  let decoder = new TextDecoder("utf8");
  let updatesBox = DOCUMENT.getElementById("updates") as HTMLPreElement;
  let delta = notification.update?.updateData as DeltaUpdate;
  let newUpdate = decoder.decode(Uint8Array.from(delta.delta));
  let newUpdateJson = JSON.parse(newUpdate.replace("\x00", ""));
  updatesBox.textContent = updatesBox.textContent + newUpdateJson;
}
</code></pre>
<h3 id="building-and-packaging-a-contract"><a class="header" href="#building-and-packaging-a-contract">Building and packaging a contract</a></h3>
<p>Now that we have the front end and the back end of our web app, we can package
the contracts and run them in the node to test them out.</p>
<p>In order to do that, we can again use the development tool to help us out with
the process. But before doing that, let's take a look at the manifesto format
and understand the different parameters that allow us to specify how this
contract should be compiled (check the <a href="./manifest.html">manifest</a> details for
more information). In the web app directory, we have a <code>freenet.toml</code> file which
contains something similar to:</p>
<pre><code class="language-toml">[contract]
type = "webapp"
lang = "rust"

...

[webapp.state-sources]
source_dirs = ["dist"]
</code></pre>
<p>This means that the <code>dist</code> directory will be packaged as the initial state for
the webapp (that is the code the browser will be interpreting and in the end,
rendering).</p>
<p>If we add the following keys to the manifesto:</p>
<pre><code class="language-toml">[webapp.dependencies]
posts = { path = "../backend" }
</code></pre>
<p>The WASM code from the <code>backend</code> contract will be embedded in our web
application state, so it will be accessible as a resource just via the local
HTTP gateway access and then we can re-use it for publishing additional
contracts.</p>
<!--
TODO: Publishing to the real functioning Freenet network is not yet supported.
-->
<p>Currently, wep applications follow a standarized build procedure in case you use
<code>fdev</code> and assumptions about your system. For example, in the case of a <code>type = "webapp"</code> contract, if nothing is specified, it will assume you have <code>npm</code> and
the <code>tsc</code> compiler available at the directory level, as well as <code>webpack</code>
installed.</p>
<p>This means that you have installed either globally or at the directory level,
e.g. globally:</p>
<pre><code class="language-bash">npm install -g typescript webpack webpack-cli
</code></pre>
<p>or locally (make sure your <code>package.json</code> file has the required dependencies):</p>
<pre><code class="language-bash">npm install --save-dev typescript webpack webpack-cli
</code></pre>
<p>If, however, you prefer to follow a different workflow, you can write your own
by enabling/disabling certain parameters or using a blank template. For example:</p>
<pre><code class="language-toml">[contract]
lang = "rust"

[state]
files = ["my_packaged_web.tar.xz"]
</code></pre>
<p>Would just delegate the work of building the packaged <code>tar</code> to the developer.
Or:</p>
<pre><code class="language-toml">[contract]
type = "webapp"
lang = "rust"

[webapp]
lang = "typescript"

[webapp.typescript]
webpack =  false
</code></pre>
<p>would disable using <code>webpack</code> at all.</p>
<p>Now that we understand the details, and after making any necessary changes, in
each contract directory we run the following commands:</p>
<pre><code class="language-bash">fdev build
</code></pre>
<p>This command will read your contract manifest file (<code>freenet.toml</code>) and take
care of building the contract and packaging it, ready for the node and the
network to consume it.</p>
<!--
TODO: Elsewhere in the documentation, explain the intricate details of building and deploying contracts, in case the use-case doesn't fit with the current tooling, so they know the necessary steeps to interact with the node at a lower level.
-->
<p>Under the <code>./build/freenet</code> directory, you will see both a <code>*.wasm</code> file, which
is the contract file, and <code>contract-state</code>, in case it applies, which is the
initial state that will be uploaded when initially putting the contract.</p>
<p>Web applications can access the code of backend contracts directly in their
applications and put new contracts (that is, assigning a new location for the
code, plus any parameters that may be generated dynamically by the web app, and
the initial state for that combination of contract code + parameters)
dynamically.</p>
<p>Let's take a look at the manifest for our web app container contract:</p>
<h2 id="testing-out-contracts-in-the-local-node"><a class="header" href="#testing-out-contracts-in-the-local-node">Testing out contracts in the local node</a></h2>
<p>Once we have all our contracts sorted and ready for testing, we can do this in
local mode in our node. For this the node must be running, we can make sure that
is running by running the following command as a background process or in
another terminal; since we have installed it:</p>
<pre><code class="language-bash">freenet
</code></pre>
<p>You should see some logs printed via the stdout of the process indicating that
the node HTTP gateway is running.</p>
<p>Once the HTTP gateway is running, we are ready to publish the contracts to our
local Freenet node:</p>
<pre><code class="language-bash">cd ../backend &amp;&amp; fdev publish --code="./build/freenet/backend.wasm" --state="./build/freenet/contract-state"
cd ../web &amp;&amp; fdev publish --code="./build/freenet/web.wasm" --state="./build/freenet/contract-state"
</code></pre>
<p>In this case, we're not passing any parameters (so our parameters will be an
empty byte array), and we are passing an initial state without the current
backend contract. In typical use, both the parameters would have meaningful
data, and the backend contract may be dynamically generated from the app and
published from there.</p>
<p>Once this is done, you can start your app just by pointing to it in the browser:
<code>http://127.0.0.1:50509/contract/web/&lt;CONTRACT KEY&gt;</code></p>
<p>For example
<code>http://127.0.0.1:50509/contract/web/CYXGxQGSmcd5xHRJNQygPwmUJsWS2njh3pdVjfVz9EV/</code></p>
<p>Iteratively you can repeat this process of modifying, and publishing locally
until you are confident with the results and ready to publish your application.</p>
<p>Since the web is part of your state, you are always able to update it, pointing
to new contracts, and evolving it over time.</p>
<h2 id="limitations"><a class="header" href="#limitations">Limitations</a></h2>
<ul>
<li>
<p>Publishing to the Freenet network is not yet supported.</p>
</li>
<li>
<p>Only Rust is currently supported for contract development, but we'll support
more languages like <a href="https://www.assemblyscript.org/">AssemblyScript</a> in the
future.</p>
</li>
<li>
<p>Binaries for all the required tools are not yet available, they must be
compiled from source</p>
</li>
</ul>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="architecture/transport.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="contract-interface.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="architecture/transport.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="contract-interface.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->
        <script src="mermaid.min.js"></script>
        <script src="mermaid-init.js"></script>


    </div>
    </body>
</html>
