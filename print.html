<!DOCTYPE HTML>
<html lang="en" class="light" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Freenet Manual</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body class="sidebar-visible no-js">
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('light')
            html.classList.add(theme);
            var body = document.querySelector('body');
            body.classList.remove('no-js')
            body.classList.add('js');
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var body = document.querySelector('body');
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            body.classList.remove('sidebar-visible');
            body.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="introduction.html"><strong aria-hidden="true">1.</strong> Introduction</a></li><li class="chapter-item expanded affix "><li class="part-title">Components</li><li class="chapter-item expanded "><a href="components/overview.html"><strong aria-hidden="true">2.</strong> Overview</a></li><li class="chapter-item expanded "><a href="components/contracts.html"><strong aria-hidden="true">3.</strong> Contracts</a></li><li class="chapter-item expanded "><a href="components/delegates.html"><strong aria-hidden="true">4.</strong> Delegates</a></li><li class="chapter-item expanded "><a href="components/ui.html"><strong aria-hidden="true">5.</strong> User Interfaces</a></li><li class="chapter-item expanded affix "><li class="part-title">Architecture</li><li class="chapter-item expanded "><a href="architecture/p2p-network.html"><strong aria-hidden="true">6.</strong> P2P Network</a></li><li class="chapter-item expanded "><a href="architecture/irouting.html"><strong aria-hidden="true">7.</strong> Intelligent Routing</a></li><li class="chapter-item expanded "><a href="architecture/transport.html"><strong aria-hidden="true">8.</strong> Transport</a></li><li class="chapter-item expanded affix "><li class="part-title">Developer Guide</li><li class="chapter-item expanded "><a href="tutorial.html"><strong aria-hidden="true">9.</strong> Tutorial: Create an App</a></li><li class="chapter-item expanded "><a href="contract-interface.html"><strong aria-hidden="true">10.</strong> Contract interfaces</a></li><li class="chapter-item expanded "><a href="manifest.html"><strong aria-hidden="true">11.</strong> freenet.toml format</a></li><li class="chapter-item expanded affix "><li class="part-title">Examples</li><li class="chapter-item expanded "><a href="examples/antiflood-tokens.html"><strong aria-hidden="true">12.</strong> Antiflood Tokens</a></li><li class="chapter-item expanded "><a href="examples/blind-trust-tokens.html"><strong aria-hidden="true">13.</strong> Blind Trust Tokens</a></li><li class="chapter-item expanded affix "><li class="part-title">Community and Support</li><li class="chapter-item expanded "><a href="community.html"><strong aria-hidden="true">14.</strong> Community</a></li><li class="chapter-item expanded affix "><li class="part-title">Reference</li><li class="chapter-item expanded "><a href="glossary.html"><strong aria-hidden="true">15.</strong> Glossary</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Freenet Manual</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="introduction"><a class="header" href="#introduction">Introduction</a></h1>
<p>Freenet is a distributed, decentralized alternative to the centralized World
Wide Web, designed to unleash a new era of innovation and competition, while
protecting freedom of speech and privacy.</p>
<p>The heart of Freenet is the <a href="https://github.com/freenet/freenet-core">Core</a>,
which runs on users' computer, smartphone, or other devices. The Core is
tiny, less than 5 MB, allowing it to be installed in a matter of seconds and
is compatible with a wide range of hardware.</p>
<p><img src="freenet_in_context.svg" alt="Freenet in Context" /></p>
<p>Freenet is a <a href="architecture/p2p-network.html">peer-to-peer network</a>, which means
that computers that are part of the network self-organize into a global network
without any central authority, and the work of hosting services is distributed
among the users.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="components-of-decentralized-software"><a class="header" href="#components-of-decentralized-software">Components of Decentralized Software</a></h1>
<p>Delegates, contracts, and user interfaces (UIs) each serve distinct roles in the
Freenet ecosystem. <a href="components/contracts.html">Contracts</a> control public data, or "shared
state". <a href="components/delegates.html">Delegates</a> act as the user's agent and can store private
data on the user's behalf, while <a href="components/ui.html">User Interfaces</a> provide an interface
between these and the user through a web browser. UIs are distributed through
the P2P network via contracts.</p>
<p><img src="components/components.svg" alt="Architectural Primitives Diagram" /></p>
<h2 id="freenet-core"><a class="header" href="#freenet-core">Freenet Core</a></h2>
<p>The Freenet Core is the software that enables a user's computer to connect to
the Freenet network. Its primary functions are:</p>
<ul>
<li>Providing a user-friendly interface to access Freenet via a web browser</li>
<li>Host the user's <a href="components/delegates.html">delegates</a> and the private data they store</li>
<li>Host <a href="components/contracts.html">contracts</a> and their associated data on behalf of the
network</li>
<li>Manage communication between contracts, delegates, and UI components</li>
</ul>
<p>Built with Rust, the core is designed to be compact (ideally under 5 MB),
efficient, and capable of running on a variety of devices such as smartphones,
desktop computers, and embedded devices.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="contracts"><a class="header" href="#contracts">Contracts</a></h2>
<p>Freenet is essentially a global decentralized key-value store where keys are
WebAssembly code called Contracts. Contracts are stored in the network,
along with their data or "state". The contract controls what state is permitted
and how it can be modified, and also how to efficiently synchronize state
between peers.</p>
<p>A contract's state is just a block of bytes, and can be anything from a simple
number to a complex data structure. The contract's code defines the state's
formatting. Even the serialization format is up to the contract, so it can be
anything from JSON to Bincode, or a custom binary format.</p>
<p>Network users can read a contract's state and subscribe to receive immediate
updates if the state is modified.</p>
<p>Contracts play a similar role in Freenet to databases and real-time
publish-subscribe mechanisms in traditional online services, while being
entirely decentralized, secure, and scalable.</p>
<ul>
<li><a href="components/contracts.html#contract-operation">Contract Operation</a>
<ul>
<li><a href="components/contracts.html#state-synchronization-and-merging">State synchronization and merging</a>
<ul>
<li><a href="components/contracts.html#fundamental-concepts">Fundamental Concepts</a></li>
<li><a href="components/contracts.html#efficient-state-synchronization">Efficient State Synchronization</a></li>
</ul>
</li>
<li><a href="components/contracts.html#blog-use-case">Blog Use Case</a></li>
<li><a href="components/contracts.html#writing-a-contract-in-rust">Writing a Contract in Rust</a>
<ul>
<li><a href="components/contracts.html#the-contractinterface-trait">The <code>ContractInterface</code> Trait</a></li>
<li><a href="components/contracts.html#flexibility-versus-convenience">Flexibility versus Convenience</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="contract-operation"><a class="header" href="#contract-operation">Contract Operation</a></h2>
<h3 id="state-synchronization-and-merging"><a class="header" href="#state-synchronization-and-merging">State synchronization and merging</a></h3>
<h4 id="fundamental-concepts"><a class="header" href="#fundamental-concepts">Fundamental Concepts</a></h4>
<p>Contracts need to provide a mechanism to merge any two valid states, creating a
new state that integrates both. This process ensures the eventual consistency of
contract states in Freenet, a concept similar to <a href="https://en.wikipedia.org/wiki/Conflict-free_replicated_data_type">Conflict-free Replicated Data
Types</a>.</p>
<p>As a very simple example, if the contract's state is a single number, then the
contract could define the merging of two states as the maximum of the two numbers.</p>
<p>In mathematical terms, a contract defines a <a href="https://mathworld.wolfram.com/CommutativeMonoid.html">commutative
monoid</a> on the contract's
state - but you can ignore this if you're not a mathematician.</p>
<h4 id="efficient-state-synchronization"><a class="header" href="#efficient-state-synchronization">Efficient State Synchronization</a></h4>
<p>Naively we could transfer the entire state between peers, but this would be
inefficient for larger states. Instead, Freenet transmits only the
difference between states.</p>
<p>To do this a contract implements three functions:</p>
<ul>
<li>
<p><code>summarize_state</code> - Returns a concise summary of the contract's
state.</p>
</li>
<li>
<p><code>get_state_delta</code> - Compares the contract's state against the summary of
another state and returns the difference between the two, the "delta".</p>
</li>
<li>
<p><code>update_state</code> - Applies a delta to the contract's state, updating it to
bring it in sync with the other peer's contract state.</p>
</li>
</ul>
<p>Contracts can implement these functions however they wish depending on the
type of data their state contains.</p>
<h5 id="step-by-step"><a class="header" href="#step-by-step">Step-by-step</a></h5>
<p>PeerA and PeerB need to synchronize their states. The algorithm for efficient
state synchronization consists of the following steps:</p>
<ol>
<li>
<p><strong>Summarize State by Initiator</strong>: PeerA compiles a concise summary of its
current state using the <code>summarize_state</code> function.</p>
<ul>
<li>This summary is transmitted to PeerB</li>
</ul>
</li>
<li>
<p><strong>Compare State at Receiver</strong>: PeerB uses <code>get_state_delta</code> to compare the
summary against its own state.</p>
<ul>
<li>If they are different, proceed to the next step; if not, synchronization is
complete.</li>
</ul>
</li>
<li>
<p><strong>Send Delta</strong>: If the states are different, PeerB calculates the delta and
sends it to PeerA.</p>
</li>
<li>
<p><strong>Apply Delta</strong>: PeerA applies this received delta to its state using
<code>update_state</code>.</p>
</li>
<li>
<p><strong>Reverse Synchronization</strong>: This process is repeated in the opposite direction.</p>
</li>
</ol>
<p>This approach allows peers to synchronize state over the network while minimizing
data transfer.</p>
<h3 id="blog-use-case"><a class="header" href="#blog-use-case">Blog Use Case</a></h3>
<p>Consider a public blog contract. The state of this contract would be the blog's
content, including blog posts. The contract's code requires that new
posts can only be added if they are signed by the blog's owner. The owner's
public key is part of the contract's parameters.</p>
<p>The contract would summarize its state by returning a list of post identifiers,
and the state delta would be a list of new posts. The contract would apply the
delta by appending the new posts to its list of posts. The contract may have
a limit on the number of posts it can store, in which case it would remove old
posts to make room for new ones.</p>
<h3 id="writing-a-contract-in-rust"><a class="header" href="#writing-a-contract-in-rust">Writing a Contract in Rust</a></h3>
<p>Freenet Contracts can be written in any programming language that compiles to
WebAssembly, but as Freenet is written in Rust it is currently the best supported
language for writing contracts.</p>
<h4 id="the-contractinterface-trait"><a class="header" href="#the-contractinterface-trait">The <code>ContractInterface</code> Trait</a></h4>
<p>Rust contracts implement the <code>ContractInterface</code> trait, which defines the
functions that the core calls to interact with the contract. This trait is
defined in the
<a href="https://github.com/freenet/freenet-stdlib/blob/f28e6716364b4e1c9ae8837344286393a2da4c82/rust/src/contract_interface.rs#L446">freenet-stdlib</a>.</p>
<pre><code class="language-rust no_run noplayground">/// # ContractInterface
///
/// This trait defines the core functionality for managing and updating a contract's state.
/// Implementations must ensure that state delta updates are *commutative*. In other words,
/// when applying multiple delta updates to a state, the order in which these updates are
/// applied should not affect the final state. Once all deltas are applied, the resulting
/// state should be the same, regardless of the order in which the deltas were applied.
///
/// Noncompliant behavior, such as failing to obey the commutativity rule, may result
/// in the contract being deprioritized or removed from the p2p network.
pub trait ContractInterface {
    /// Verify that the state is valid, given the parameters.
    fn validate_state(
        parameters: Parameters&lt;'static&gt;,
        state: State&lt;'static&gt;,
        related: RelatedContracts&lt;'static&gt;,
    ) -&gt; Result&lt;ValidateResult, ContractError&gt;;

    /// Update the state to account for the new data
    fn update_state(
        parameters: Parameters&lt;'static&gt;,
        state: State&lt;'static&gt;,
        data: Vec&lt;UpdateData&lt;'static&gt;&gt;,
    ) -&gt; Result&lt;UpdateModification&lt;'static&gt;, ContractError&gt;;

    /// Generate a concise summary of a state that can be used to create deltas
    /// relative to this state.
    fn summarize_state(
        parameters: Parameters&lt;'static&gt;,
        state: State&lt;'static&gt;,
    ) -&gt; Result&lt;StateSummary&lt;'static&gt;, ContractError&gt;;

    /// Generate a state delta using a summary from the current state.
    /// This along with [`Self::summarize_state`] allows flexible and efficient
    /// state synchronization between peers.
    fn get_state_delta(
        parameters: Parameters&lt;'static&gt;,
        state: State&lt;'static&gt;,
        summary: StateSummary&lt;'static&gt;,
    ) -&gt; Result&lt;StateDelta&lt;'static&gt;, ContractError&gt;;
}</code></pre>
<h4 id="flexibility-versus-convenience"><a class="header" href="#flexibility-versus-convenience">Flexibility versus Convenience</a></h4>
<p>The <code>ContractInterface</code> trait is a low-level "Layer 0" API that provides direct
access to the contract's state and parameters. This API is useful for contracts
that require fine-grained control over their state, but can be cumbersome.</p>
<p>Soon we will provide higher-level APIs on top of Layer 0 that will sacrifice
some flexibility for ease of contract implementation.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="delegates"><a class="header" href="#delegates">Delegates</a></h1>
<p>In Freenet, Delegates are software components that can act on the user's behalf.
Think of them as a more sophisticated version of a web browser's local storage,
with similarities to Unix "Daemons". Operating within the Freenet core on your
device, Delegates are a secure and flexible mechanism for managing private data,
such as cryptographic keys, tokens, and passwords, and executing complex tasks.</p>
<p>Delegates interact with various components within Freenet, including Contracts,
User Interfaces, and other Delegates. They can also communicate directly with
the user, such as to request user permissions or notify the user of events.</p>
<p>Implemented in WebAssembly and adhering to the
<a href="https://github.com/freenet/freenet-core/blob/b1e59528eaeba31c7f09881594d19347de60e8cd/crates/freenet-stdlib/src/delegate_interface.rs#L121">DelegateInterface</a>
trait, Delegates seamlessly integrate within the Freenet network, operating
securely on your devices.</p>
<h2 id="actor-model-and-message-passing"><a class="header" href="#actor-model-and-message-passing">Actor Model and Message Passing</a></h2>
<p>Delegates communicate with Contracts, other Delegates, and UIs by passing
messages, similar to the <a href="https://en.wikipedia.org/wiki/Actor_model">actor
model</a>.</p>
<p>The Freenet Core makes sure that for any incoming message, whether it's from
another Delegate, a User Interface, or a Contract update, the receiver knows who
the sender is. This allows delegates to verify the behavior of any component
they interact with, and decide if they can be trusted.</p>
<h2 id="delegate-use-cases"><a class="header" href="#delegate-use-cases">Delegate Use Cases</a></h2>
<p>Delegates have a wide variety of uses:</p>
<ul>
<li>
<p>A <strong>key manager delegate</strong> manages a user's private keys. Other components can
request that this Delegate sign messages or other data on their behalf.</p>
</li>
<li>
<p>An <strong>inbox delegate</strong> maintains an inbox of messages sent to the user in an
email-like system. It retrieves messages from an inbox Contract, decrypts
them, and stores them locally where they can be accessed by other components
like a user interface.</p>
</li>
<li>
<p>A <strong>contacts delegate</strong> manages a user's contacts. It can store and retrieve
contact information, and can be used by other components to send messages to
contacts.</p>
</li>
<li>
<p>An <strong>alerts delegate</strong> watches for events on the network, such as a mention
of the user's name in a discussion, and notifies the user of these events
via an alert.</p>
</li>
</ul>
<p>Moreover, Delegates can securely synchronize with identical Delegate instances
running on other devices controlled by the user, such as a laptop, phone, or
desktop PC. This synchronization, facilitated through a shared secret private
key provided by the user, allows the Delegates to communicate securely, acting
as both backups and replicas of each other through Freenet's peer-to-peer
network.</p>
<h2 id="similarity-to-service-workers"><a class="header" href="#similarity-to-service-workers">Similarity to Service Workers</a></h2>
<p>Delegates have much in common with <a href="https://developer.mozilla.org/en-US/docs/Web/API/Service_Worker_API">Service Workers</a> in
the web browser ecosystem. Both are self-contained software modules, running
independently of the user interface and performing complex tasks on behalf of
the user.</p>
<p>However, Delegates are even more powerful. While Service Workers can
store data and interact with components within the scope of the web browser and
its pages, Delegates can talk to other Delegates in the same device, or with
other Delegates running elsewhere via Freenet's peer-to-peer network.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="user-interface"><a class="header" href="#user-interface">User Interface</a></h2>
<p>On the normal web, a user might visit <code>https://gmail.com/</code>, their browser
will download the Gmail user interface which then runs in their browser and connects back to the Gmail servers.</p>
<p>On Freenet the user interface is downloaded from a Freenet contract, and it
<a href="components/overview.html">interacts</a> with contracts and delegates by sending messages
through the Freenet core.</p>
<p><img src="components/ui_delegate_contract.svg" alt="Delegate, Contrat, and UI Diagram" /></p>
<p>These UIs are built using web technologies such as HTML, CSS, and JavaScript,
and are distributed over Freenet and run in a web browser. UIs can create,
retrieve, and update contracts through a WebSocket connection to the local
Freenet peer, as well as communicate with delegates.</p>
<p>Because UIs run in a web browser, they can be built using any web framework,
such as React, Angular, Vue.js, Bootstrap, and so on.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="freenet-network-topology"><a class="header" href="#freenet-network-topology">Freenet Network Topology</a></h1>
<h2 id="small-world-network"><a class="header" href="#small-world-network">Small-World Network</a></h2>
<p>Freenet is structured as a decentralized peer-to-peer network, based on the idea of
a <a href="https://en.wikipedia.org/wiki/Small-world_network">small-world network</a>. This
network topology is scalable and efficient, allowing contract state to be found
quickly and without any reliance on a central authority.</p>
<p><img src="architecture/p2p-network.svg" alt="Small World Network" /></p>
<h2 id="freenet-peers"><a class="header" href="#freenet-peers">Freenet Peers</a></h2>
<p>In Freenet, a "peer" is any computer running the <a href="https://github.com/freenet/freenet-core">Freenet
Core</a> software. The peers are organized
in a ring-like structure, with each peer assigned a specific numerical value
between 0.0 and 1.0, indicating its location in the network's topology. This
location is derived from the peer's IP address.</p>
<h2 id="establishing-neighbor-connections"><a class="header" href="#establishing-neighbor-connections">Establishing Neighbor Connections</a></h2>
<p>Every Freenet peer, also referred to as a node, forms two-way connections with a
set of other peers, termed "neighbors." These connections utilize the User
Datagram Protocol (UDP) and can do <a href="https://en.wikipedia.org/wiki/Hole_punching_(networking)">Frewall hole punching</a> when necessary. Peers manage their resource usage —
bandwidth, memory, CPU, and storage — based on limits set by the user.</p>
<h2 id="adaptive-behavior"><a class="header" href="#adaptive-behavior">Adaptive behavior</a></h2>
<p>Peers keep track of their neighbor's performance and learn to prefer faster
connections over time.</p>
<p>Peers can also identify bad behavior by other peers like excess resource usage and
will disconnect from them.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="intelligent-routing"><a class="header" href="#intelligent-routing">Intelligent Routing</a></h2>
<p>Freenet's request routing mechanism plays a crucial role in the efficiency of
the network.</p>
<p>It is responsible for deciding which peer to route a request to when attempting
to read, create, or modify a contract's state. The mechanism is designed to
select the peer that can complete the request the fastest, which may not always
be the peer closest to the contract's location - the traditional approach for
routing in a small-world network, known as <a href="https://en.wikipedia.org/wiki/Small-world_routing#Greedy_routing">greedy
routing</a>.</p>
<h3 id="isotonic-regression"><a class="header" href="#isotonic-regression">Isotonic Regression</a></h3>
<p>Freenet uses <a href="https://github.com/sanity/pav.rs">isotonic regression</a>, a method
for estimating a monotonically increasing or decreasing function given a set of
data, to predict the response time from a peer based on its ring distance from
the target location of the request.</p>
<p>This estimation is then adjusted by the average difference between the isotonic
regression estimate and the actual response time from previous interactions with
the peer. This process enables a form of adaptive routing that selects the peer
with the lowest estimated response time.</p>
<h3 id="router-initialization-and-event-handling"><a class="header" href="#router-initialization-and-event-handling">Router Initialization and Event Handling</a></h3>
<p>When a new
<a href="https://github.com/freenet/freenet-core/blob/main/crates/core/src/router.rs">Router</a>
is created, it's initialized with a history of routing events. These events are
processed to generate the initial state of the isotonic estimators. For example,
failure outcomes and success durations are computed for each event in the
history and used to initialize the respective estimators. The average transfer
size is also computed from the history.</p>
<p>The Router can add new events to its history, updating its estimators in the
process. When a successful routing event occurs, the Router updates its response
start time estimator, failure estimator, and transfer rate estimator based on
the details of the event. If a failure occurs, only the failure estimator is
updated.</p>
<h3 id="peer-selection"><a class="header" href="#peer-selection">Peer Selection</a></h3>
<p>To select a peer for routing a request, the Router first checks whether it has
sufficient historical data. If not, it selects the peer with the minimum
distance to the contract location. If it does have sufficient data, it predicts
the outcome of routing the request to each available peer and selects the one
with the best predicted outcome.</p>
<h3 id="outcome-prediction"><a class="header" href="#outcome-prediction">Outcome Prediction</a></h3>
<p>To predict the outcome of routing a request to a specific peer, the Router uses
its isotonic estimators to predict the time to the start of the response, the
chance of failure, and the transfer rate. These predictions are used to compute
an expected total time for the request, with the cost of a failure being assumed
as a multiple of the cost of success. The peer with the lowest expected total
time is selected for routing the request.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="freenet-transport-protocol-frtp"><a class="header" href="#freenet-transport-protocol-frtp">Freenet Transport Protocol (FrTP)</a></h1>
<p><strong>Note</strong>: This document is a work in progress and is subject to change, it is currently out-of-sync
with the codebase and should be updated to reflect the current state of the codebase once it has
stabilized.</p>
<h2 id="introduction-1"><a class="header" href="#introduction-1">Introduction</a></h2>
<p>The Freenet Transport Protocol (FrTP) is a UDP-based system designed to ensure reliable and encrypted
message transmission. This document outlines the key elements of FrTP, including connection
establishment, message handling, and rate limiting.</p>
<h2 id="overview"><a class="header" href="#overview">Overview</a></h2>
<ul>
<li><strong>Firewall Traversal</strong>: FrTP allows peers behind firewalls to establish direct connections.</li>
<li><strong>Security</strong>: All messages are encrypted using AES128GCM, with RSA public key exchange for
connection establishment, should effectively thwart man-in-the-middle attacks.</li>
<li><strong>Streaming</strong>: Large messages can be streamed, meaning that a peer can start forwarding data
before the entire message is received.</li>
<li><strong>Covert</strong>: FrTP can run on any UDP port and FrTP packets look like random data, although more
sophisticated analysis of packet timing and size could be used to identify FrTP traffic. FrTP
can't be port-scanned as it won't respond to packets unless encrypted with the peer's public key.</li>
<li><strong>Efficient</strong>: FrTP is designed to minimize bandwidth usage, with rate limiting and confirmation
message batching.</li>
</ul>
<h2 id="connection-establishment"><a class="header" href="#connection-establishment">Connection Establishment</a></h2>
<h3 id="scenario-1-both-peers-behind-nat"><a class="header" href="#scenario-1-both-peers-behind-nat">Scenario 1: Both Peers Behind NAT</a></h3>
<p>This describes how to establish one side of a two-way connection, allowing Bob to send messages
to Alice. The process is symmetric in the other direction.</p>
<h4 id="actors"><a class="header" href="#actors">Actors</a></h4>
<ul>
<li>Alice and Bob are both peers behind firewalls.</li>
</ul>
<h4 id="terminology"><a class="header" href="#terminology">Terminology</a></h4>
<ul>
<li><code>Bob_public_key</code>: Bob's RSA public key.</li>
<li><code>Bob_private_key</code>: Bob's RSA private key.</li>
<li><code>Alice_inbound_symmetric_key</code>: AES128GCM symmetric key generated by Alice, used for decrypting
inbound messages from Bob.</li>
<li><code>hello_message(A-&gt;B)</code>: Message sent from Alice to Bob, containing <code>Alice_inbound_symmetric_key</code>
and a u16 protocol version number, encrypted using <code>B_public_key</code>.</li>
<li><code>hello_ack(B-&gt;A)</code>: Message sent from Bob to Alice acknowledging <code>hello_message(A-&gt;B)</code>,
encrypted using <code>Alice_inbound_symmetric_key</code>.</li>
</ul>
<h4 id="steps"><a class="header" href="#steps">Steps</a></h4>
<ol>
<li>
<p><strong>Key Generation</strong>: Alice generates a random AES128GCM symmetric key,
called <code>Alice_inbound_symmetric_key</code>.</p>
</li>
<li>
<p><strong>Outbound Hello Message</strong>: Alice encrypts <code>Alice_inbound_symmetric_key</code> with <code>Bob_public_key</code> and
a u16 protocol version number with Peer B's public key, to create <code>hello_message(A-&gt;B)</code>.</p>
</li>
<li>
<p><strong>Sending Outbound Hello</strong>: Alice repeatedly sends <code>hello_message(A-&gt;B)</code> every 200ms until
a <code>hello_ack(B-&gt;A)</code> from Bob is received or a 5-second timeout occurs, indicating connection
failure.</p>
</li>
<li>
<p><strong>Receiving Inbound Hello</strong>: Bob receives <code>hello_message(A-&gt;B)</code> and decrypts it using
<code>Bob_private_key</code>. If the protocol version is not supported, then Bob sends a <code>hello_ack(B-&gt;A)</code>
with an error code and terminates the connection.</p>
</li>
<li>
<p><strong>Hello Acknowledgement</strong>: Upon receiving <code>hello_ack(B-&gt;A)</code>, Alice stops sending <code>hello_message(A-&gt;B)</code>
and the inbound side of the connection is established.</p>
</li>
<li>
<p><strong>Unexpected Hello Messages</strong>: If Bob receives a <code>hello_message(A-&gt;B)</code> from Alice after
it has already sent a <code>hello_ack(B-&gt;A)</code>, then it should resend the <code>hello_ack(B-&gt;A)</code> and
otherwise ignore the message (this may occur if the initial <code>hello_ack(B-&gt;A)</code> is lost).</p>
</li>
</ol>
<h3 id="scenario-2-peer-behind-nat-connects-to-gateway-peer"><a class="header" href="#scenario-2-peer-behind-nat-connects-to-gateway-peer">Scenario 2: Peer behind NAT connects to Gateway peer</a></h3>
<h4 id="actors-1"><a class="header" href="#actors-1">Actors</a></h4>
<ul>
<li>Alice is a peer behind a firewall, Gateway isn't behind a firewall and is configured to act as a
gateway peer for new peers to assimiate into the network.</li>
</ul>
<h4 id="terminology-1"><a class="header" href="#terminology-1">Terminology</a></h4>
<ul>
<li><code>Gateway_public_key</code>: Gateway's RSA public key.</li>
<li><code>Gateway_private_key</code>: Gateway's RSA private key.</li>
<li><code>Alice_bidirectional_symmetric_key</code>: AES128GCM symmetric key generated by Alice, used for encrypting
and decrypting messages to/from Gateway.</li>
</ul>
<h4 id="steps-1"><a class="header" href="#steps-1">Steps</a></h4>
<ol>
<li>
<p><strong>Key Generation</strong>: Alice generates a random AES128GCM symmetric key,
called <code>Alice_bidrectional_symmetric_key</code>.</p>
</li>
<li>
<p><strong>Outbound Hello Message</strong>: Alice encrypts <code>Alice_bidrectional_symmetric_key</code> with <code>Gateway_public_key</code> and
a u16 protocol version number with Gateway's public key, to create <code>hello_message(A-&gt;G)</code>.</p>
</li>
<li>
<p><strong>Sending Outbound Hello</strong>: Alice repeatedly sends <code>hello_message(A-&gt;B)</code> every 200ms until
a <code>hello_ack(G-&gt;A)</code> from Gateway is received or a 5-second timeout occurs, indicating connection
failure.</p>
</li>
<li>
<p><strong>Receiving Inbound Hello</strong>: Gateway receives <code>hello_message(A-&gt;G)</code> and decrypts it using
<code>Gateway_private_key</code>. If the protocol version is not supported, then Gateway sends a <code>hello_ack(G-&gt;A)</code>
with an error code and terminates the connection, otherwise it sends a <code>hello_ack(G-&gt;A)</code> to Alice.</p>
</li>
<li>
<p><strong>Hello Acknowledgement</strong>: Upon receiving <code>hello_ack(G-&gt;A)</code>, Alice stops sending <code>hello_message(A-&gt;G)</code>,
and the the connection is established, Alice should use <code>Alice_bidirectional_symmetric_key</code> for
both encryption and decryption of packets sent to and received from Gateway.</p>
</li>
</ol>
<h2 id="keep-alive-protocol"><a class="header" href="#keep-alive-protocol">Keep-Alive Protocol</a></h2>
<p>To maintain an open connection, <code>keep_alive</code> messages are exchanged every 30 seconds. A connection
is terminated if a peer fails to receive any message within 120 seconds.</p>
<h2 id="symmetric-message-schema"><a class="header" href="#symmetric-message-schema">Symmetric Message Schema</a></h2>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub(super) struct SymmetricMessage {
    pub packet_id: PacketId,
    pub confirm_receipt: Vec&lt;PacketId&gt;,
    pub payload: SymmetricMessagePayload,
}

pub(super) enum SymmetricMessagePayload {
    AckConnection {
        // if we successfully connected to a remote we attempt to connect to initially
        // then we return our TransportPublicKey so they can enroute other peers to us
        result: Result&lt;(), Cow&lt;'static, str&gt;&gt;,
    },
    GatewayConnection {
        // a gateway acknowledges a connection and returns the private key to use
        // for communication
        key: [u8; 16],
    },
    ShortMessage {
        payload: MessagePayload,
    },
    StreamFragment {
        stream_id: StreamId,
        total_length_bytes: u64, // we shouldn't allow messages larger than u32, that's already crazy big
        fragment_number: u32,
        payload: MessagePayload,
    },
    NoOp,
}

pub enum HelloError {
    UnsupportedProtocolVersion {
      min_supported: u16,
      max_supported: u16,
      your_version: u16
    },
}
<span class="boring">}</span></code></pre></pre>
<h2 id="message-handling"><a class="header" href="#message-handling">Message Handling</a></h2>
<h3 id="dropped-and-out-of-order-messages"><a class="header" href="#dropped-and-out-of-order-messages">Dropped and Out-of-Order Messages</a></h3>
<ul>
<li><strong>Duplicate Detection</strong>: Messages are checked for duplicate <code>message_id</code>. Duplicates trigger
an immediate <code>NoOperation</code> message with a reconfirmation in <code>confirm_receipt</code>.</li>
<li><strong>Acknowledgement Timeout</strong>: Messages are resent if not acknowledged within 2 seconds
(<code>MESSAGE_CONFIRMATION_TIMEOUT</code>).</li>
</ul>
<h3 id="confirmation-batching"><a class="header" href="#confirmation-batching">Confirmation Batching</a></h3>
<ul>
<li><strong>Batching Strategy</strong>: Receipts can be delayed up to 500ms (<code>MAX_CONFIRMATION_DELAY</code>) to enable
batch confirmation.</li>
<li><strong>Queue Management</strong>: Receipt queues exceeding 20 messages prompt immediate confirmation to
prevent overflow.</li>
</ul>
<h2 id="message-types"><a class="header" href="#message-types">Message Types</a></h2>
<ul>
<li><strong>Short Messages</strong>: Contained within a single UDP packet (up to 1kb).</li>
<li><strong>Long Messages</strong>: Split into fragments for larger payloads, enabling efficient data forwarding.</li>
</ul>
<h2 id="rate-limiting"><a class="header" href="#rate-limiting">Rate Limiting</a></h2>
<ul>
<li><strong>Initial Setup</strong>: Upstream bandwidth set 50% above desired usage to allow for traffic bursts.</li>
<li><strong>Dynamic Adjustment</strong>: Future adaptations may use isotonic regression for optimizing bandwidth
and packet loss
balance.</li>
<li><strong>Implementation</strong>: Bandwidth monitoring over 10-second windows (<code>BANDWIDTH_MEASUREMENT_WINDOW</code>).
Exceeding limits
triggers a 10ms sleep (<code>BANDWIDTH_CONTROL_SLEEP_DURATION</code>), with periodic reassessment.</li>
</ul>
<h2 id="implementation-notes"><a class="header" href="#implementation-notes">Implementation Notes</a></h2>
<h3 id="serialization"><a class="header" href="#serialization">Serialization</a></h3>
<ul>
<li>Try to avoid unnecessary copies of data, especially for large messages.</li>
<li>Ensure serialization format is robust against untrustedf data.</li>
<li>Note that there will be nested layers of serialization, both internal to FrTP and
by the FrTP user.</li>
</ul>
<p>Consider:</p>
<ul>
<li><a href="https://crates.io/crates/flatbuffers/">FlatBuffers</a></li>
<li><a href="https://docs.rs/serde_bytes/latest/serde_bytes/">Serde Bytes</a></li>
<li><a href="https://github.com/bincode-org/bincode">BinCode</a></li>
</ul>
<h2 id="conclusion"><a class="header" href="#conclusion">Conclusion</a></h2>
<p>The Freenet Transport Protocol provides a robust framework for secure and efficient data
transmission. Its design considers NAT challenges, message integrity, and bandwidth management,
ensuring reliable communication in various network conditions.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="introduction-2"><a class="header" href="#introduction-2">Introduction</a></h1>
<p>This tutorial will show you how to build decentralized software on Freenet. For a practical
reference, please see the example application at <a href="https://github.com/freenet/freenet-core/tree/main/apps/freenet-email-app">apps/freenet-email-app</a>.</p>
<ul>
<li><a href="tutorial.html#prerequisites">Prerequisites</a>
<ul>
<li><a href="tutorial.html#rust-and-cargo">Rust and Cargo</a>
<ul>
<li><a href="tutorial.html#note-for-macos-install">Note for MacOS install</a></li>
</ul>
</li>
<li><a href="tutorial.html#installing-freenet-core-and-fdev-from-git">Installing Freenet Core and FDev from Git</a></li>
<li><a href="tutorial.html#freenet-development-tool-and-kernel">Freenet Development Tool and Kernel</a></li>
<li><a href="tutorial.html#add-webassembly-target">Add WebAssembly target</a></li>
<li><a href="tutorial.html#nodejs-and-typescript">Node.js and TypeScript</a></li>
</ul>
</li>
<li><a href="tutorial.html#creating-a-new-contract">Creating a new contract</a></li>
<li><a href="tutorial.html#making-a-container-contract">Making a container contract</a>
<ul>
<li><a href="tutorial.html#creating-a-web-application">Creating a web application</a></li>
</ul>
</li>
<li><a href="tutorial.html#writing-the-backend-for-our-web-application">Writing the backend for our web application</a>
<ul>
<li><a href="tutorial.html#building-and-packaging-a-contract">Building and packaging a contract</a></li>
</ul>
</li>
<li><a href="tutorial.html#testing-out-contracts-in-the-local-node">Testing out contracts in the local node</a></li>
<li><a href="tutorial.html#limitations">Limitations</a></li>
</ul>
<h2 id="prerequisites"><a class="header" href="#prerequisites">Prerequisites</a></h2>
<h3 id="rust-and-cargo"><a class="header" href="#rust-and-cargo">Rust and Cargo</a></h3>
<p>To install a Rust development environment, including Cargo, on Linux or macOS
(for Windows installation, refer to <a href="https://rustup.rs">this guide</a>), use the
following command:</p>
<pre><code class="language-bash">curl https://sh.rustup.rs -sSf | sh
</code></pre>
<h4 id="note-for-macos-install"><a class="header" href="#note-for-macos-install">Note for MacOS install</a></h4>
<p>Note: The Homebrew installation of Rust may interfere with <code>fdev</code>. It is
recommended to use <code>rustup</code>, as shown above, to avoid these issues.</p>
<h3 id="installing-freenet-core-and-fdev-from-git"><a class="header" href="#installing-freenet-core-and-fdev-from-git">Installing Freenet Core and FDev from Git</a></h3>
<ul>
<li>Clone the Freenet Core repository and the stdlib submodule, and navigate to the application directory:</li>
</ul>
<p><em>Note:</em> Currently these should be installed from the git repo as the code is changing rapidly, once things
are more stable they can be installed from crates.io which will simplify this step.</p>
<pre><code class="language-bash">git clone --recurse-submodules https://github.com/freenet/freenet-core.git
cd freenet-core/apps/freenet-ping
</code></pre>
<h3 id="freenet-development-tool-and-kernel"><a class="header" href="#freenet-development-tool-and-kernel">Freenet Development Tool and Kernel</a></h3>
<ul>
<li>
<p>Install the Freenet development tool (<code>fdev</code>) and the Freenet kernel for local development:</p>
<pre><code class="language-bash"># You should be in freenet-core/apps/freenet-ping
cargo install --path ../../crates/core
cargo install --path ../../crates/fdev
</code></pre>
</li>
</ul>
<h3 id="add-webassembly-target"><a class="header" href="#add-webassembly-target">Add WebAssembly target</a></h3>
<p>To allow Rust to compile to WebAssembly, you need to add the WebAssembly target using <code>rustup</code>:</p>
<pre><code class="language-bash">rustup target add wasm32-unknown-unknown
</code></pre>
<h3 id="nodejs-and-typescript"><a class="header" href="#nodejs-and-typescript">Node.js and TypeScript</a></h3>
<p>To build user interfaces in JavaScript or TypeScript, you need to have Node.js
and npm installed. For example on Ubuntu Linux:</p>
<pre><code class="language-bash">sudo apt update
sudo apt install nodejs npm
</code></pre>
<p>For Mac or Windows, you can download Node.js and npm from <a href="https://nodejs.org/en/download/">here</a>.</p>
<p>Once Node.js and npm are installed, you can install TypeScript globally on your
system, which includes the <code>tsc</code> command:</p>
<pre><code class="language-bash">sudo npm install -g typescript
</code></pre>
<p>You can verify the installation by checking the version of <code>tsc</code>:</p>
<pre><code class="language-bash">tsc --version
</code></pre>
<p>This command should output the version of TypeScript that you installed.</p>
<h2 id="creating-a-new-contract"><a class="header" href="#creating-a-new-contract">Creating a new contract</a></h2>
<p>You can create a new <a href="glossary.html#contract">contract</a> skeleton by executing the
<code>new</code> command with <code>fdev</code>. Fdev supports two types of contracts:
regular <a href="glossary.html#contract">contracts</a>, and <a href="glossary.html#web-application">web application</a> <a href="glossary.html#container-contract">container
contracts</a>. Fdev supports several languages:</p>
<ul>
<li>Regular contracts:
<ul>
<li>Rust (<em>default</em>)</li>
</ul>
</li>
<li>Web applications:
<ul>
<li>Container development:
<ul>
<li>Rust (<em>default</em>)</li>
</ul>
</li>
<li>Web/state development:
<ul>
<li>TypeScript. (<em>default: using npm and webpack</em>)</li>
<li>JavaScript.</li>
<li>Rust (<strong>WIP</strong>).</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>We create a directory to hold our web app, and initialize it using <code>fdev</code>:</p>
<pre><code class="language-bash">mkdir -p my-app/web
mkdir -p my-app/backend
cd my-app/web
fdev new web-app
</code></pre>
<p>This will create the skeleton for a web application and its container contract for
Freenet ready for development at the <code>my-app/web</code> directory.</p>
<h2 id="making-a-container-contract"><a class="header" href="#making-a-container-contract">Making a container contract</a></h2>
<p>The first thing that we need is to write the code for our container contract.
This contract's role is to contain the web application code itself, allowing it
to be distributed over Freenet.</p>
<p>The <code>new</code> command has created the source ready to be modified for us, in your
favorite editor open the following file:</p>
<pre><code class="language-bash">./container/src/lib.rs
</code></pre>
<p>In this case, and for simplicity's sake, the contract won't be performing any
functions, but in a realistic scenario, this contract would include some basic
security functionality like verifying that whoever is trying to update the
contract has the required credentials.</p>
<p>To make our contract unique so it doesn't collide with an existing contract, we
can generate a random signature that will be embedded with the contract.</p>
<!--
What would happen in case of a collision with an existing contract? (That would be if we try to publish a contract that has the same combination of code and parameters.) Then it would fail to publish our contract in the network and would get a rejection because we would be trying to update an existing contract. And we would have to make a slight change in the code/parameters so this collision is avoided. To make this work, there needs to exist a type, which requires (this can be only done once, at the top level of the library crate) implementing the `ContractInterface` trait from `freenet-stdlib`.
-->
<p>For example in the <code>lib.rs</code> file we will write the following:</p>
<pre><code class="language-rust no_run noplayground">use freenet_stdlib::prelude::*;

pub const RANDOM_SIGNATURE: &amp;[u8] = &amp;[6, 8, 2, 5, 6, 9, 9, 10];

struct Contract;

#[contract]
impl ContractInterface for Contract {
    fn validate_state(
        _parameters: Parameters&lt;'static&gt;,
        _state: State&lt;'static&gt;,
        _related: RelatedContracts&lt;'static&gt;,
    ) -&gt; Result&lt;ValidateResult, ContractError&gt; {
        unimplemented!()
    }

    fn update_state(
        _parameters: Parameters&lt;'static&gt;,
        _state: State&lt;'static&gt;,
        _data: Vec&lt;UpdateData&lt;'static&gt;&gt;,
    ) -&gt; Result&lt;UpdateModification&lt;'static&gt;, ContractError&gt; {
        unimplemented!()
    }

    fn summarize_state(
        _parameters: Parameters&lt;'static&gt;,
        _state: State&lt;'static&gt;,
    ) -&gt; Result&lt;StateSummary&lt;'static&gt;, ContractError&gt; {
        unimplemented!()
    }

    fn get_state_delta(
        _parameters: Parameters&lt;'static&gt;,
        _state: State&lt;'static&gt;,
        _summary: StateSummary&lt;'static&gt;,
    ) -&gt; Result&lt;StateDelta&lt;'static&gt;, ContractError&gt; {
        unimplemented!()
    }
}</code></pre>
<p>That's a lot of information, let's unpack it:</p>
<pre><code class="language-rust noplayground">use freenet_stdlib::prelude::*;</code></pre>
<p>Here we are importing the necessary types and traits to write a Freenet contract
successfully using Rust.</p>
<pre><code class="language-rust noplayground">pub const RANDOM_SIGNATURE: &amp;[u8] = &amp;[6, 8, 2, 5, 6, 9, 9, 10];</code></pre>
<p>This will make our contract unique, notice the <code>pub</code> qualifier so the compiler
doesn't remove this constant because is unused and is included in the output of
the compiler.</p>
<pre><code class="language-rust noplayground">struct Contract;

#[contract]
impl ContractInterface for Contract {
  ...
}</code></pre>
<!--
TODO: Elsewhere in the documentation, explain the intricate details of how interfacing through WASM works. In theory users could implement their own wrapping code as long as the follow the low level WASM code specification.
-->
<p>Here we create a new type, <code>Contract</code> for which we will be implementing the
<code>ContractInterface</code> trait. To know more details about the functionality of a
contract, delve into the details of the <a href="contract-interface.html">contract
interface</a>.</p>
<p>Notice the <code>#[contract]</code> macro call, this will generate the necessary code for
the WASM runtime to interact with your contract ergonomically and safely. Trying
to use this macro more than once in the same module will result in a compiler
error, and only the code generated at the top-level module will be used by the
runtime.</p>
<p>As a rule of thumb, one contract will require implementing the
`ContractInterface`` exactly once.</p>
<h3 id="creating-a-web-application"><a class="header" href="#creating-a-web-application">Creating a web application</a></h3>
<p>Now we have a working example of a contract, but our contract is an empty shell,
which does not do anything yet. To change this, we will start developing our web
application.</p>
<p>To do that, we can go and modify the code of the contract state, which in this
case is the web application. Freenet offers a standard library (stdlib) that can
be used with Typescript/JavaScript to facilitate the development of web
applications and interfacing with your local node, so we will make our
<code>package.json</code> contains the dependency:</p>
<pre><code class="language-json">{
  "dependencies": {
    "@freenetorg/freenet-stdlib": "0.0.6"
  }
}
</code></pre>
<p>Open the file <code>src/index.ts</code> in a code editor and you can start developing the
web application.</p>
<p>An important thing to notice is that our application will need to interface with
our local node, the entry point for our machine to communicate with other nodes
in the network. The stdlib offers a series of facilities in which you will be
able to communicate with the network ergonomically.</p>
<p>Here is an example of how you could write your application to interact with the
node:</p>
<pre><code class="language-typescript">import {
  GetResponse,
  HostError,
  Key,
  FreenetWsApi,
  PutResponse,
  UpdateNotification,
  UpdateResponse,
  DelegateResponse,
} from "@freenetorg/freenet-stdlib/websocket-interface";

const handler = {
  onContractPut: (_response: PutResponse) =&gt; {},
  onContractGet: (_response: GetResponse) =&gt; {},
  onContractUpdate: (_up: UpdateResponse) =&gt; {},
  onContractUpdateNotification: (_notif: UpdateNotification) =&gt; {},
  onDelegateResponse: (_response: DelegateResponse) =&gt; {},
  onErr: (err: HostError) =&gt; {},
  onOpen: () =&gt; {},
};

const API_URL = new URL(`ws://${location.host}/contract/command/`);
const freenetApi = new FreenetWsApi(API_URL, handler);

const CONTRACT = "DCBi7HNZC3QUZRiZLFZDiEduv5KHgZfgBk8WwTiheGq1";

async function loadState() {
  let getRequest = {
    key: Key.fromSpec(CONTRACT),
    fetch_contract: false,
  };
  await freenetApi.get(getRequest);
}
</code></pre>
<p>Let's unpack this code:</p>
<pre><code class="language-typescript">const handler = {
  onPut: (_response: PutResponse) =&gt; {},
  onGet: (_response: GetResponse) =&gt; {},
  onUpdate: (_up: UpdateResponse) =&gt; {},
  onUpdateNotification: (_notif: UpdateNotification) =&gt; {},
  onErr: (err: HostError) =&gt; {},
  onOpen: () =&gt; {},
};

const API_URL = new URL(`ws://${location.host}/contract/command/`);
const freenetApi = new FreenetWsApi(API_URL, handler);
</code></pre>
<p>This type provides a convenient interface to the WebSocket API. It receives an
object which handles the different responses from the node via callbacks. Here
you would be able to interact with DOM objects or other parts of your code.</p>
<pre><code class="language-typescript">const CONTRACT = "DCBi7HNZC3QUZRiZLFZDiEduv5KHgZfgBk8WwTiheGq1";

async function loadState() {
  let getRequest = {
    key: Key.fromSpec(CONTRACT),
    fetch_contract: false,
  };
  await freenetApi.get(getRequest);
}
</code></pre>
<p>Here we use the API wrapper to make a get request (which requires a key and
specifies if we require fetching the contract code or not) to get the state for
a contract with the given address. The response from the node will be directed
to the <code>onGet</code> callback. You can use any other methods available in the API to
interact with the node.</p>
<!--
TODO: Add a link to documentation for the WebSocket API in typescript
-->
<h2 id="writing-the-backend-for-our-web-application"><a class="header" href="#writing-the-backend-for-our-web-application">Writing the backend for our web application</a></h2>
<p>In the <a href="dev-guide.html#creating-a-new-contract">creating a new contract</a> section
we described the contract interface, but we were using it to write a simple
container contract that won't be doing anything in practice, just carrying
around the front end of your application. The core logic of the application, and
a back end where we will be storing all the information, requires another
contract. So we will create a new contract in a different directory for it:</p>
<pre><code class="language-bash">cd ../backend
fdev new contract
</code></pre>
<p>This will create a regular contract, and we will need to implement the interface
on a type that will handle our contract code. For example:</p>
<pre><code class="language-rust noplayground">use freenet_stdlib::prelude::*;

pub const RANDOM_SIGNATURE: &amp;[u8] = &amp;[6, 8, 2, 5, 6, 9, 9, 10];

struct Contract;

struct Posts(...)

impl Posts {
  fn add_post(&amp;mut self, post: Post) { ... }
}

struct Post(...)

#[contract]
impl ContractInterface for Contract {
    fn update_state(
        _parameters: Parameters&lt;'static&gt;,
        state: State&lt;'static&gt;,
        data: Vec&lt;UpdateData&lt;'static&gt;&gt;,
    ) -&gt; Result&lt;UpdateModification&lt;'static&gt;, ContractError&gt; {
        let mut posts: Posts = serde_json::from_slice(&amp;state).map_err(|_| ContractError::InvalidState)?;
        if let Some(UpdateData::Delta(delta)) = data.pop() {
          let new_post: Posts = serde_json::from_slice(&amp;delta).map_err(|_| ContractError::InvalidState);
          posts.add_post(new_post)?;
        } else {
            Err(ContractError::InvalidUpdate)
        }
        Ok(UpdateModification::valid(posts.into()))
    }

    ...
}</code></pre>
<p>In this simple example, we convert a new incoming delta to a post and the state
to a list of posts we maintain, and we append the post to the list of posts.
After that, we convert back the posts list to an state and return that.</p>
<p>If we subscribe to the contract changes or our web app, we will receive a
notification with the updates after they are successful, and we will be able to
render them in our browser. We can do that, for example, using the API:</p>
<pre><code class="language-typescript">function getUpdateNotification(notification: UpdateNotification) {
  let decoder = new TextDecoder("utf8");
  let updatesBox = DOCUMENT.getElementById("updates") as HTMLPreElement;
  let delta = notification.update?.updateData as DeltaUpdate;
  let newUpdate = decoder.decode(Uint8Array.from(delta.delta));
  let newUpdateJson = JSON.parse(newUpdate.replace("\x00", ""));
  updatesBox.textContent = updatesBox.textContent + newUpdateJson;
}
</code></pre>
<h3 id="building-and-packaging-a-contract"><a class="header" href="#building-and-packaging-a-contract">Building and packaging a contract</a></h3>
<p>Now that we have the front end and the back end of our web app, we can package
the contracts and run them in the node to test them out.</p>
<p>In order to do that, we can again use the development tool to help us out with
the process. But before doing that, let's take a look at the manifesto format
and understand the different parameters that allow us to specify how this
contract should be compiled (check the <a href="./manifest.html">manifest</a> details for
more information). In the web app directory, we have a <code>freenet.toml</code> file which
contains something similar to:</p>
<pre><code class="language-toml">[contract]
type = "webapp"
lang = "rust"

...

[webapp.state-sources]
source_dirs = ["dist"]
</code></pre>
<p>This means that the <code>dist</code> directory will be packaged as the initial state for
the webapp (that is the code the browser will be interpreting and in the end,
rendering).</p>
<p>If we add the following keys to the manifesto:</p>
<pre><code class="language-toml">[webapp.dependencies]
posts = { path = "../backend" }
</code></pre>
<p>The WASM code from the <code>backend</code> contract will be embedded in our web
application state, so it will be accessible as a resource just via the local
HTTP gateway access and then we can re-use it for publishing additional
contracts.</p>
<!--
TODO: Publishing to the real functioning Freenet network is not yet supported.
-->
<p>Currently, wep applications follow a standarized build procedure in case you use
<code>fdev</code> and assumptions about your system. For example, in the case of a <code>type = "webapp"</code> contract, if nothing is specified, it will assume you have <code>npm</code> and
the <code>tsc</code> compiler available at the directory level, as well as <code>webpack</code>
installed.</p>
<p>This means that you have installed either globally or at the directory level,
e.g. globally:</p>
<pre><code class="language-bash">npm install -g typescript webpack webpack-cli
</code></pre>
<p>or locally (make sure your <code>package.json</code> file has the required dependencies):</p>
<pre><code class="language-bash">npm install --save-dev typescript webpack webpack-cli
</code></pre>
<p>If, however, you prefer to follow a different workflow, you can write your own
by enabling/disabling certain parameters or using a blank template. For example:</p>
<pre><code class="language-toml">[contract]
lang = "rust"

[state]
files = ["my_packaged_web.tar.xz"]
</code></pre>
<p>Would just delegate the work of building the packaged <code>tar</code> to the developer.
Or:</p>
<pre><code class="language-toml">[contract]
type = "webapp"
lang = "rust"

[webapp]
lang = "typescript"

[webapp.typescript]
webpack =  false
</code></pre>
<p>would disable using <code>webpack</code> at all.</p>
<p>Now that we understand the details, and after making any necessary changes, in
each contract directory we run the following commands:</p>
<pre><code class="language-bash">fdev build
</code></pre>
<p>This command will read your contract manifest file (<code>freenet.toml</code>) and take
care of building the contract and packaging it, ready for the node and the
network to consume it.</p>
<!--
TODO: Elsewhere in the documentation, explain the intricate details of building and deploying contracts, in case the use-case doesn't fit with the current tooling, so they know the necessary steeps to interact with the node at a lower level.
-->
<p>Under the <code>./build/freenet</code> directory, you will see both a <code>*.wasm</code> file, which
is the contract file, and <code>contract-state</code>, in case it applies, which is the
initial state that will be uploaded when initially putting the contract.</p>
<p>Web applications can access the code of backend contracts directly in their
applications and put new contracts (that is, assigning a new location for the
code, plus any parameters that may be generated dynamically by the web app, and
the initial state for that combination of contract code + parameters)
dynamically.</p>
<p>Let's take a look at the manifest for our web app container contract:</p>
<h2 id="testing-out-contracts-in-the-local-node"><a class="header" href="#testing-out-contracts-in-the-local-node">Testing out contracts in the local node</a></h2>
<p>Once we have all our contracts sorted and ready for testing, we can do this in
local mode in our node. For this the node must be running, we can make sure that
is running by running the following command as a background process or in
another terminal; since we have installed it:</p>
<pre><code class="language-bash">freenet
</code></pre>
<p>You should see some logs printed via the stdout of the process indicating that
the node HTTP gateway is running.</p>
<p>Once the HTTP gateway is running, we are ready to publish the contracts to our
local Freenet node:</p>
<pre><code class="language-bash">cd ../backend &amp;&amp; fdev publish --code="./build/freenet/backend.wasm" --state="./build/freenet/contract-state"
cd ../web &amp;&amp; fdev publish --code="./build/freenet/web.wasm" --state="./build/freenet/contract-state"
</code></pre>
<p>In this case, we're not passing any parameters (so our parameters will be an
empty byte array), and we are passing an initial state without the current
backend contract. In typical use, both the parameters would have meaningful
data, and the backend contract may be dynamically generated from the app and
published from there.</p>
<p>Once this is done, you can start your app just by pointing to it in the browser:
<code>http://127.0.0.1:50509/contract/web/&lt;CONTRACT KEY&gt;</code></p>
<p>For example
<code>http://127.0.0.1:50509/contract/web/CYXGxQGSmcd5xHRJNQygPwmUJsWS2njh3pdVjfVz9EV/</code></p>
<p>Iteratively you can repeat this process of modifying, and publishing locally
until you are confident with the results and ready to publish your application.</p>
<p>Since the web is part of your state, you are always able to update it, pointing
to new contracts, and evolving it over time.</p>
<h2 id="limitations"><a class="header" href="#limitations">Limitations</a></h2>
<ul>
<li>
<p>Publishing to the Freenet network is not yet supported.</p>
</li>
<li>
<p>Only Rust is currently supported for contract development, but we'll support
more languages like <a href="https://www.assemblyscript.org/">AssemblyScript</a> in the
future.</p>
</li>
<li>
<p>Binaries for all the required tools are not yet available, they must be
compiled from source</p>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="contract-interface"><a class="header" href="#contract-interface">Contract Interface</a></h1>
<h2 id="terms"><a class="header" href="#terms">Terms</a></h2>
<ul>
<li><a href="glossary.html#contract-state">Contract State</a> - data associated with a contract that can be retrieved by Applications and Delegates.</li>
<li><a href="glossary.html#delta">Delta</a> - Represents a modification to some state - similar to a <a href="https://en.wikipedia.org/wiki/Diff">diff</a> in source code</li>
<li><a href="glossary.html#parameters">Parameters</a> - Data that forms part of a contract along with the WebAssembly code</li>
<li><a href="glossary.html#state-summary">State Summary</a> - A compact summary of a contract's state that can be used to create a delta</li>
</ul>
<h2 id="interface"><a class="header" href="#interface">Interface</a></h2>
<p>Freenet contracts must implement the contract interface from <a href="https://github.com/freenet/freenet-stdlib/blob/main/rust/src/contract_interface.rs#L446-L483">stdlib/rust/src/contract_interface.rs</a>:</p>
<pre><code class="language-rust no_run noplayground">/// # ContractInterface
///
/// This trait defines the core functionality for managing and updating a contract's state.
/// Implementations must ensure that state delta updates are *commutative*. In other words,
/// when applying multiple delta updates to a state, the order in which these updates are
/// applied should not affect the final state. Once all deltas are applied, the resulting
/// state should be the same, regardless of the order in which the deltas were applied.
///
/// Noncompliant behavior, such as failing to obey the commutativity rule, may result
/// in the contract being deprioritized or removed from the p2p network.
pub trait ContractInterface {
    /// Verify that the state is valid, given the parameters.
    fn validate_state(
        parameters: Parameters&lt;'static&gt;,
        state: State&lt;'static&gt;,
        related: RelatedContracts&lt;'static&gt;,
    ) -&gt; Result&lt;ValidateResult, ContractError&gt;;

    /// Update the state to account for the new data
    fn update_state(
        parameters: Parameters&lt;'static&gt;,
        state: State&lt;'static&gt;,
        data: Vec&lt;UpdateData&lt;'static&gt;&gt;,
    ) -&gt; Result&lt;UpdateModification&lt;'static&gt;, ContractError&gt;;

    /// Generate a concise summary of a state that can be used to create deltas
    /// relative to this state.
    fn summarize_state(
        parameters: Parameters&lt;'static&gt;,
        state: State&lt;'static&gt;,
    ) -&gt; Result&lt;StateSummary&lt;'static&gt;, ContractError&gt;;

    /// Generate a state delta using a summary from the current state.
    /// This along with [`Self::summarize_state`] allows flexible and efficient
    /// state synchronization between peers.
    fn get_state_delta(
        parameters: Parameters&lt;'static&gt;,
        state: State&lt;'static&gt;,
        summary: StateSummary&lt;'static&gt;,
    ) -&gt; Result&lt;StateDelta&lt;'static&gt;, ContractError&gt;;
}</code></pre>
<p><code>Parameters</code>, <code>State</code>, and <code>StateDelta</code> are all wrappers around simple <code>[u8]</code> byte arrays for maximum efficiency and flexibility.</p>
<h2 id="contract-interaction"><a class="header" href="#contract-interaction">Contract Interaction</a></h2>
<p>In the (hopefully) near future we'll be adding the ability for contracts to read each other's state while validating and updating their own, see <a href="https://github.com/freenet/freenet-core/issues/167">issue #167</a> for the latest on this.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="the-manifest-format"><a class="header" href="#the-manifest-format">The Manifest Format</a></h1>
<p>The <code>freenet.toml</code> file for each UI component/contract is called its <em>manifest</em>.
It is written in the <a href="https://toml.io/">TOML</a> format. Manifest files consist of
the following sections:</p>
<ul>
<li><a href="./manifest.html#the-contract-section">[contract]</a> — Defines a contract.
<ul>
<li><a href="./manifest.html#the-type-field">type</a> — Contract type.</li>
<li><a href="./manifest.html#the-lang-field">lang</a> — Contract source language.</li>
<li><a href="./manifest.html#the-output_dir-field">output_dir</a> — Output path for build
artifacts.</li>
</ul>
</li>
<li><a href="./manifest.html#the-contract-section">[webapp]</a> — Configuration for UI
component containers.</li>
<li><a href="./manifest.html#the-state-section">[state]</a> — Optionally seed a state.</li>
</ul>
<h2 id="the-contract-section"><a class="header" href="#the-contract-section">The <code>[contract]</code> section</a></h2>
<h3 id="the-type-field"><a class="header" href="#the-type-field">The <code>type</code> field</a></h3>
<pre><code class="language-toml">[contract]
...
type = "webapp"
</code></pre>
<p>The type of the contract being packaged. Currently the following types are
supported:</p>
<ul>
<li><code>standard</code>, the default type, it can be ellided. This is just a standard
<a href="./glossary.html#contract">contract</a>.</li>
<li><code>webapp</code>, a web app <a href="./glossary.html#container-contract">container contract</a>.
Additionally to the container contract the UI component source will be
compiled and packaged as the state of the contract.</li>
</ul>
<h3 id="the-lang-field"><a class="header" href="#the-lang-field">The <code>lang</code> field</a></h3>
<pre><code class="language-toml">[contract]
...
lang = "rust"
</code></pre>
<p>The programming language in which the contract is written. If specified the
build tool will compile the contract. Currently only Rust is supported.</p>
<h3 id="the-output_dir-field"><a class="header" href="#the-output_dir-field">The <code>output_dir</code> field</a></h3>
<pre><code class="language-toml">[contract]
...
output_dir = "./other/output/dir/"
</code></pre>
<p>An optional path to the output directory for the build artifacts. If not set the
output will be written to the relative directory <code>./build/freenet</code> from the
manifest file directory.</p>
<h2 id="the-webapp-section"><a class="header" href="#the-webapp-section">The <code>[webapp]</code> section</a></h2>
<p>An optional section, only specified in case of <code>webapp</code> contracts.</p>
<h3 id="the-lang-field-1"><a class="header" href="#the-lang-field-1">The <code>lang</code> field</a></h3>
<pre><code class="language-toml">[webapp]
...
lang =  "typescript"
</code></pre>
<p>The programming language in which the web application is written. Currently the
following languages are supported:</p>
<ul>
<li><code>typescript</code>, requires <a href="https://www.npmjs.com/">npm</a> installed.</li>
<li><code>javascript</code>, requires <a href="https://www.npmjs.com/">npm</a> installed.</li>
</ul>
<h3 id="the-metadata-field"><a class="header" href="#the-metadata-field">The <code>metadata</code> field</a></h3>
<pre><code class="language-toml">[webapp]
...
metadata =  "/path/to/metadata/file"
</code></pre>
<p>An optional path to the metadata for the webapp, if not set the metadata will be
empty.</p>
<h3 id="the-webapptypescript-options-section"><a class="header" href="#the-webapptypescript-options-section">The <code>[webapp.typescript]</code> options section</a></h3>
<p>Optional section specified in case of the the <code>typescript</code> lang.</p>
<p>The following fields are supported:</p>
<pre><code class="language-toml">[webapp.typescript]
webpack =  true
</code></pre>
<ul>
<li><code>webpack</code> — if set webpack will be used when packaging the contract state.</li>
</ul>
<h3 id="the-webappjavascript-options-section"><a class="header" href="#the-webappjavascript-options-section">The <code>[webapp.javascript]</code> options section</a></h3>
<p>Optional section specified in case of the the <code>javascript</code> lang.</p>
<p>The following fields are supported:</p>
<pre><code class="language-toml">[webapp.javascript]
webpack =  true
</code></pre>
<ul>
<li><code>webpack</code> — if set webpack will be used when packaging the contract state.</li>
</ul>
<h3 id="the-webappstate-sources-options-section"><a class="header" href="#the-webappstate-sources-options-section">The <code>[webapp.state-sources]</code> options section</a></h3>
<pre><code class="language-toml">[webapp.state-sources]
source_dirs =  ["path/to/sources"]
files = ["*/src/**.js"]
</code></pre>
<p>Specifies the sources for the state of the contract, this will be later on
unpacked and accessible at the HTTP gateway from the Locutus node. Includes any
web sources (like .html or .js files). The <code>source_dirs</code> field is a comma
separated array of directories that should be appended to the root of the state,
the <code>files</code> field is a comma separated array of
<a href="https://en.wikipedia.org/wiki/Glob_(programming)">glob</a> compatible patterns
to files that will be appendeded to the state.</p>
<p>At least one of <code>source_dirs</code>or <code>files</code> fields are required.</p>
<h3 id="the-webappdependencies-section"><a class="header" href="#the-webappdependencies-section">The <code>[webapp.dependencies]</code> section</a></h3>
<pre><code class="language-toml">[webapp.dependencies]
...
posts = { path = "../contracts/posts" }
</code></pre>
<p>An optional list of contract dependencies that will be embedded and available in
the state of the contract. Each entry under this entry represents an alias to
the contract code, it must include a <code>path</code> field that specifies the relative
location of the dependency from this manifesto directory.</p>
<p>If dependencies are specified they will be compiled and appended to the contract
state, under the <code>contracts</code> directory, and as such, become available from the
HTTP gateway. A <code>dependencies.json</code> file will be automatically generated and
placed under such directory that maps the aliases to the file and hash of the
code generated for the dependencies.</p>
<p>In this way the "parent" container contract can use those contracts code to
put/update new values through the websocket API in an ergonomic manner.</p>
<h2 id="the-state-section"><a class="header" href="#the-state-section">The <code>[state]</code> section</a></h2>
<pre><code class="language-toml">[state]
files = ["*/src/**.js"]
</code></pre>
<p>An optional section for standard contracts in case they want to seed an state
initially, it will take a single file and make it available at the build
directory.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="example-antiflood-token-system"><a class="header" href="#example-antiflood-token-system">Example: Antiflood Token System</a></h1>
<h2 id="purpose"><a class="header" href="#purpose">Purpose</a></h2>
<p>The Antiflood Token System (AFT) is a decentralized system aimed to provide a
simple, but general purpose solution to flooding, denial-of-service attacks,
and spam.</p>
<p>AFT allows users to generate tokens through a "token generator", which is
created by completing a "hard" task, such as making a donation to Freenet.
Tokens are generated at a fixed rate and can be utilized to perform activities,
such as sending messages.</p>
<p>The recipient can specify the required token "tier," with each tier being
generated at different intervals (e.g. 1 minute, 1 hour). This way, if a
recipient experiences a high volume of messages, they can increase the token
tier to make it more challenging to generate, thus reducing the flood.</p>
<h2 id="aft-delegate"><a class="header" href="#aft-delegate">AFT Delegate</a></h2>
<p>The AFT relies on a
<a href="https://github.com/freenet/freenet-core/blob/f1c8075e173f171c17ffa8d08803b2c9aea4ddf3/modules/antiflood-tokens/components/token-generator/src/lib.rs#L17">TokenDelegate</a>
that implements this DelegateInterface.</p>
<h4 id="token-generator"><a class="header" href="#token-generator">Token Generator</a></h4>
<p>The
<a href="https://github.com/freenet/freenet-core/blob/f1c8075e173f171c17ffa8d08803b2c9aea4ddf3/modules/antiflood-tokens/contracts/token-allocation-record/src/lib.rs#L10">TokenAllocContract</a>
keeps track of token assignments to ensure that tokens are not double spent.
New tokens are generated at a fixed rate that depends on the tier required by
the recipient.</p>
<h4 id="recepient-inbox"><a class="header" href="#recepient-inbox">Recepient Inbox</a></h4>
<p>The recipient inbox contract keeps track of inbound messages sent to a
recipient, verifying that each is accompanied by a valid token of the required
tier.</p>
<h2 id="sequence-diagram"><a class="header" href="#sequence-diagram">Sequence Diagram</a></h2>
<pre class="mermaid">sequenceDiagram
  participant User
  participant Application
  participant Delegate
  participant TokenGeneratorContract
  participant RecipientInboxContract

  User-&gt;&gt;Application: 1. RequestToken
  Application-&gt;&gt;Delegate: 2. RequestToken
  Delegate-&gt;&gt;User: 3. Allocate?
  User-&gt;&gt;Delegate: 4. approved
  Delegate-&gt;&gt;TokenGeneratorContract: 5. TokenAllocation
  Delegate-&gt;&gt;RecipientInboxContract: 6. Message+TokenAllocation
  RecipientInboxContract-&gt;&gt;TokenGeneratorContract: 7. verify
  TokenGeneratorContract-&gt;&gt;RecipientInboxContract: 8. verified
</pre>
<ol>
<li>
<p>User requests a token from the application, perhaps by composing a message
and clicking "send" in the UI</p>
</li>
<li>
<p>The application requests a token from the delegate via its websocket
connection to the Freenet node</p>
</li>
<li>
<p>The delegate requests permission from the user to allocate a token, this
occurs independently of the application, perhaps via an OS-specific
notification mechanism</p>
</li>
<li>
<p>The user approves the allocation</p>
</li>
<li>
<p>The delegate allocates a token to the token generator contract</p>
</li>
<li>
<p>The delegate sends the message and token allocation to the recipient inbox
contract</p>
</li>
<li>
<p>The recipient inbox contract verifies that the token allocation is valid
before appending the inbound message to its state</p>
</li>
<li>
<p>The token generator contract verifies that the token allocation is valid and
adds it to its list of allocations</p>
</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="blind-attestations"><a class="header" href="#blind-attestations">Blind Attestations</a></h1>
<h2 id="overview-1"><a class="header" href="#overview-1">Overview</a></h2>
<p>A mechanism to attest the owner of a "target" contract performed some action,
while preserving the owner's anonymity using a <a href="https://en.wikipedia.org/wiki/Blind_signature">blind
signature</a>.</p>
<p>A typical use would be for the Freenet non-profit to attest that the owner of a
particular contract made a donation to project. The owner can then use this
attestation to prove they made a donation, without revealing their identity to
Freenet or anyone else.</p>
<p>This contract could then be thought to have a value of the donation amount,
this could then serve as collateral to secure a transaction with a
counterparty, such as a purchase or a loan.</p>
<p>To do this, the contract would allow the contract owner to temporarily give the
counterparty the ability to "disable" the contract for a mutually agreed period
of time. The parties then conduct their transaction. If the counterparty is
dissatisfied with the transaction then they can disable the contract as
punishment, during which time it cannot be used.</p>
<h2 id="attestation"><a class="header" href="#attestation">Attestation</a></h2>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let contract_key = // The contract which we want Freenet to attest to
let (blinded_attestation_request, blind_key) = BlindAttestationRequest::blind(
    &amp;mut rng,
    &amp;contract_key,
);
<span class="boring">}</span></code></pre></pre>
<p>The contract owner then sends the blinded attestation request to Freenet:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// URL is https://freenet.org/attestation?blinded_contract_key=4F6oPq...
open_in_browser(&amp;blinded_attestation_request.to_url());
<span class="boring">}</span></code></pre></pre>
<p>The user then follows the instructions on freenet.org to complete the donation.
Once the donation is complete, freenet.org signs the blinded_contract_key and
sends the attestation response through a response contract in Freenet. This
may also be sent via a browser redirect to the application.</p>
<p>The attestation consists of:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Attestation {
    pub signature : Signature,
    pub authorization : Authorization,
    pub authorization_sig : Signature,

    /// 
    fn is_valid(&amp;self) -&gt; Result&lt;Authorization, String&gt; {
        if (!signature.verify(&amp;authorization.pubkey, &amp;self.target)) {
            return Err("The target's signature is invalid");
        }

        if (!authorization_sig.verify(&amp;freenet_public_key, &amp;self.authorization)) {
            return Err("The authorization's signature is invalid");
        }

        Ok(self.authorization)
    }
}

enum Authorization {
    FreenetDonation(pubkey : PublicKey, amount_range : (Money, Money), time_range : (Timestamp, Timestamp)),
}

enum Target {
    Contract(ContractKey),
}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="community"><a class="header" href="#community">Community</a></h1>
<ul>
<li><a href="https://github.com/freenet/freenet-core">Github</a></li>
<li><a href="https://matrix.to/#/#locutus:matrix.org">Matrix</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="glossary"><a class="header" href="#glossary">Glossary</a></h1>
<h2 id="application"><a class="header" href="#application">Application</a></h2>
<p>Software that uses Freenet as a back-end. This includes native software
distributed independenly of Freenet but which uses Freenet as a back-end
(perhaps bundling Freenet), and <a href="glossary#web-application">web applications</a>
that are distributed over Freenet and run in a web browser.</p>
<h2 id="contract"><a class="header" href="#contract">Contract</a></h2>
<p>A contract is WebAssembly code with associated data like the contract state. The
role of the contract is to determine:</p>
<ul>
<li>Is the state valid for this contract?</li>
<li>Under what circumstances can the state be modified or updated? (see Delta)</li>
<li>How can two valid states be merged to produce a third valid state?</li>
</ul>
<h2 id="container-contract"><a class="header" href="#container-contract">Container Contract</a></h2>
<p>A contract that contains an application or component as state, accessed through
the web proxy.</p>
<p>For example, if the contract id is
<code>6C2KyVMtqw8D5wWa8Y7e14VmDNXXXv9CQ3m44PC9YbD2</code> then visiting
<code>http://localhost:PORT/contract/web/6C2KyVMtqw8D5wWa8Y7e14VmDNXXXv9CQ3m44PC9YbD2</code>
will cause the application/component to be retrieved from Freenet, decompressed,
and sent to the browser where it can execute.</p>
<h2 id="contract-state"><a class="header" href="#contract-state">Contract State</a></h2>
<p>Data associated with a contract that can be retrieved by Applications and
Components. For efficiency and flexibility, contract state is represented as a
simple <code>[u8]</code> byte array.</p>
<h2 id="delegate"><a class="header" href="#delegate">Delegate</a></h2>
<p>A delegate is a piece of software that runs on the user's computer and acts on
the user's behalf. Similar to local storage in a web browser, delegates can
store private data on the user's computer and control how it is used. Delegates
can also interact with contracts, applications, and other delegates.</p>
<h2 id="delta"><a class="header" href="#delta">Delta</a></h2>
<p>Represents a modification to some state - similar to a
<a href="https://en.wikipedia.org/wiki/Diff">diff</a> in source code. The exact format of a
delta is determined by the contract. A contract will determine whether a delta
is valid - perhaps by verifying it is signed by someone authorized to modify the
contract state. A delta may be created in response to a <a href="glossary.html#state-summary">State
Summary</a> as part of the <a href="glossary.html#state-synchronization">State
Synchronization</a> mechanism.</p>
<h2 id="parameters"><a class="header" href="#parameters">Parameters</a></h2>
<p>Data that forms part of a contract along with the WebAssembly code. This is
supplied to the contract as a parameter to the contract's functions. Parameters
are typically be used to configure a contract, much like the parameters of a
constructor function.</p>
<p>For example, the parameters could contain a hash of the state itself. The
contract would then use it to verify that the state hashes to that value. This
would create a contract that is guaranteed to contain the same state. In the
original Freenet, this was known as a <a href="http://justsolve.archiveteam.org/wiki/Content_Hash_Key_(Freenet)">content hash
key</a>.</p>
<h2 id="state-summary"><a class="header" href="#state-summary">State Summary</a></h2>
<p>Given a contract state, this is a small piece of data that can be used to
determine a <a href="glossary.html#delta">delta</a> between two contracts as part of the
<a href="glossary.html#state-synchronization">state synchronization</a> mechanism. The format
of a state summary is determined by the state's contract.</p>
<h2 id="state-synchronization"><a class="header" href="#state-synchronization">State Synchronization</a></h2>
<p>Given two valid states for a contract, the state synchronization mechanism
allows the states to be efficiently merged over the network to ensure <a href="https://en.wikipedia.org/wiki/Eventual_consistency">eventual
consistency</a>.</p>
<h2 id="web-application"><a class="header" href="#web-application">Web Application</a></h2>
<p>Software built on Freenet and distributed through Freenet.</p>
<p>Applications run in the browser and can be built with tools like React,
TypeScript, and Vue.js. An application may use multiple components and
<a href="glossary.html#contract">contracts</a>.</p>
<p>Applications are compressed and distributed via a <a href="glossary.html#container-contract">container
contract</a>.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->
        <script src="mermaid.min.js"></script>
        <script src="mermaid-init.js"></script>

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </div>
    </body>
</html>
